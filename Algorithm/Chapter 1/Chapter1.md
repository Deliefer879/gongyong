# Chapter 1

자료구조를 선택하는 적절한 지표에는 **시간 복잡도**가 있다.  
</br>
연속된 자료구조는 모든 원소를 단일 메모리 청크(하나의 연속된 메모리 덩어리)에 저장 ex) 배열  
</br>
정적 배열은 선언된 블록이 끝나면 소멸되며 스택 메모리 영역에 할당.  
동적 배열은 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 결정가능하며 힙 영역에 할당.  
</br>
배열 같은 연속된 자료구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때  
그 옆에 있는 원소 몇 개도 함께 캐시로 가져오며 다시 주변 원소로 접근 시 해당 원소를 캐시에서 가져옴.  
이러한 속성을 캐시 지역성이라고 함  
</br>
연결된 자료구조는 노드라고 하는 여러 개의 메모리 청크에 데이터를 저장 ex) 연결 리스트  
연결 리스트에서는 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할수 없음.  
따라서 모든 원소를 차례대로 방문하는 작업은 이론적으로는 같은 시간 복잡도이지만 실제로는 배열이 우세함.  
</br>
std::array <- 크기가 컴파일 시간에 결정되는 상수이여야 함, 항상 스택 메모리를 사용  
std::vector <- 원소 크기를 지정하지 않고 선언가능, 힙 메모리 사용  
std::forward_list <- 기본적인 연결 리스트(한 방향으로만 이동 가능)  
std::list <- 양방향 이동이 가능한 리스트  
std::deque <- 양방향 큐(크기가 같은 여러 개의 메모리 청크를 사용, 이러한 이유로 기존 원소들을 가르키건 반복자나 포인터가 무효화 되지 않음)
</br>
C++의 컨테이너 어댑터  
std::stack <- deque을 기본 컨테이너로 사용(vector을 사용 시 전체 원소의 이동이 있을수도 있음)  
std::queue <- deque을 기본 컨테이너로 사용(vector을 사용 시 전체 원소의 이동이 있을수도 있음)  
std::priority_queue <- vector을 기본 컨태이너로 사용(기본 컨태이너 함수를 응용하는 것이 아니라 히피파이 알고리즘을 구현)  
컨테이너 어댑터들은 각각의 자료구조에서 꼭 필요한 기능만 지원하기 때문에 반복자를 지원하지 않음
</br>
반복자의 유연성 : 순방향 < 양방향 < 임의 접근  
vector과 같이 크기 이상의 원소 추가시 새 메모리를 할당한 뒤 복사하는 경우   
원소들을 가리키던 반복자나 포인터가 무효화 될 수도있음