# Chapter4

* 클래스 P(Polynomial Time, 다항 시간) 문제  
  * 다항 시간 알고리즘을 이용하여 솔루션을 구할 수 있는 문제  
* NP(Non-Determinstic Polynomial Time, 비결정적 다항 시간) 문제  
  * 특정 솔루션을 다항 시간으로 검증할 수는 있지만 알려진 다항 시간 솔루션은 없음
* EXPTIME(Exponenitial Time, 지수 시간) 문제  
  * 입력 크기에 대한 지수 함수 형태의 시간 복잡도 솔루션을 가짐
* PSPACE(Polynomial Space, 다항식 공간) 문제  
  * 다항식 크기의 공간이 필요한 문제

</br>

분할 정복 : 주어진 문제를 작은 부분 문제로 나누고, 나눠진 각 부분 문제의 솔루션을 구하고  
각 부분 문제 솔루션을 합쳐서 전체 문제에 대한 솔루션을 구하는 방식  
</br>
선형 검색 : 정렬 여부와 상관없이 항상 잘 동작하지만 효율적이지 못함 -> O(n) 복잡도  
이진 검색 : 정렬된 상태에서만 사용 가능하지만 효율적 -> O(log n) 복잡도  
</br>
**알고리즘에서 사용하는 데이터 타입과 알고리즘 로직을 분리하는 것이**  
**모던 C++에서 재사용 가능한 코드를 작성하는 기본 방침 (연습 18번, 실습 8번 참조)**  

</br>  

정렬 알고리즘 구현에 있어 필요한 요구 사항  
1. 모든 데이터 타입에 대해 동작해야 함
2. 많은 양의 데이터를 처리할 수 있어야 한다. (외부 정렬)
3. 점근적 시간 복잡도 측면이나 실제 동작 시에 빠르게 동작해야 한다.  
</br>  

병합 정렬 : 외부 정렬 알고리즘으로  
많은 원소로 구성된 전체 집합을 작은 크기의 부분집합으로 나눠 각각을 정렬하고,  
정렬된 부분집합을 오름차순 또는 내림차순 순서를 유지하면서 합치는 방식  
</br>
퀵 정렬 : 가장 빠른 정렬 알고리즘으로 알려져 있으며  
기본 아이디어는 병합 정렬과 같음. 다만 퀵 정렬의 핵심은 병합이 아니라 분할  
</br>
선형 시간 선택 : 각 단계에서 문제를 두 개 이상으로 분할
ex) 입력 벡터 V에서 i번째로 작은 원소를 찾는 경우  
입력 벡터 V를 여러개로 분할하여 각각 정렬한 뒤 중앙값을 구하여  
집합 M을 생생하고 그 집합에서 다시한번 중앙값을 찾아 그 값을 기준으로  
전체 벡터를 2개로 분할 (P.181 ~ P.183)

</br>  

맵리듀스(더 높은 추상화 레벨의 분할 정복 기법)   
"맵리듀스는 대규모 데이터셋을 생성하고 처리하기 위한 프로그래밍 모델 및 구현으로  
사용자는 키와 값의 쌍을 처리하여 중간 단계의 키/값을 생성하는 맵 함수와 같은  
중간 단계 키에 해당하는 모든 중간 단계 값을 병합하는 리듀스 함수를 지정합니다."  
</br>
맵 : 컨테이너 C를 입력으로 받아. 컨테이너의 모든 원소에 함수 f(x)를 적용하는 연산

리듀스 : 컨테이너 C의 모든 원소 x에 함수 f(acc, x)를 적용하여 하나의 값으로 축약하는 연산
