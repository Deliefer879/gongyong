# Chapter3

해싱 : 각각의 데이터를 가급적 고유한 숫자 값으로 표현하고,  
나중에 같은 숫자 값으로 데이터를 탐색하는 작업  

해시 함수 : 주어진 데이터로부터 고유한 숫자 값을 계산하는 함수  

해시 값 : 해시 함수에 의해 반환되는 값  

충돌 : 해시 함수가 서로 다른 키에 대해 같은 해시 값을 반환하는것  
</br>

체이닝 : 충돌이 발생한 두 키값을 모두 저장 가능한 방법 중 1가지  
해시 테이블의 특정 위치에 키가 아닌 연결 리스트를 저장하여 중복되는 원소를 리스트에 저장  

</br>
열린 주소 지정 : 체이닝처럼 테이블에 리스트를 붙여서 저장하는 것이 아니라  
모든 원소를 해시 테이블 내부에 저장하는 방식으로 해시 값에 해당하는 위치가 이미 사용되고 있다면  
테이블의 다른 비어있는 위치를 탐색하며 탐색 방법에는 여러 가지 방법이 있음  
  
선형 탐색 : 가장 간단한 탐색 방법으로 충돌 발생 시  
해당 위치에서 하나씩 다음 셀 위치로 이동하면서 셀이 비어있으면 삽입  
같은 해시값이 연속으로 삽입되는 경우 데이터가 특정 위치에 군집화(clustening)되는 문제가 발생함  

이차함수 탐색 : 선형 방정식이 아닌 이차 방정식을 이용하여 다음 위치를 탐색  
선형 탐색에 비해 군집화가 나타날 확률이 적음  

**뻐꾸기 해싱** : 완벽한 해싱 기법 중의 하나로 구현만 제대로 한다면 O(1)을 보장하는 기법  
크기가 같은 두 개의 해시 테이블을 사용하고, 각각의 테이블은 서로 다른 해시 함수를 가짐  
모든 원소는 두 해시 테이블 중 하나에 있을 수 있으며, 그 위치는 해당 해시 테이블의 해시 함수에 의해 결정  

뻐꾸기 해싱과 위의 기법들과의 차이점  
* 원소가 두 해시 테이블 중 어디든 저장 가능
* 원소가 나중에 재해싱 없이 다른 위치로 이동 가능

뻐꾸기 해싱은 충돌 발생 시 다른 해시 테이블에서 위치를 탐색해 비어있으면 삽입하고 원소가 있으면  
다시 다른 해시 테이블에서 위치를 탐색해나가는 과정을 반복하면서 데이터를 추가  
</br>

C++ 해시 테이블 : 해시 테이블에 저장되는 값은 숫자가 아니라 문자일수도 있음  
그래서 C++은 문자열로부터 해시 값을 생성하는 std::hash<std::string>(std::string)함수 객체를 제공  
C++ STL은 std::unordered_set<Key>와 std::unordered_map<Key, Value> 형태로 체이닝 방식으로 구현된 해시 테이블을 제공  
</br>

블룸 필터 : 해시 테이블에 비해 공간 효율이 매우 높은 방법이지만 결정적 솔루션 대신 부정확한 결과를 얻을 수 있음  
블룸 필터는 거짓-부정이 없다는 것은 보장하지만, 거짓-긍정은 나올 수 있음  
즉 특정 원소가 존재한다는 답변을 받더라도 원소가 없을 수도 있고, 원소가 없다는 답변을 받으면 원소가 확실히 없음  

블룸 필터는 여러 개의 해시 함수를 사용하며 실제 값을 저장하는 것이 아니라 값이 있는지 없는지 나타내는 bool타입 배열을 사용